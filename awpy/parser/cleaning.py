"""Data cleaning functions."""

import difflib
from collections.abc import Sequence
from typing import Any, Literal, Protocol

import numpy as np
import pandas as pd
import textdistance


class DistMetricCallable(Protocol):
    """Class to define valid text dist callables."""

    def __call__(self, *sequences: Sequence[object]) -> float:
        """Protocol for dist metric callables.

        Take a sequence of objects and return a distance.

        Returns:
            float: Distance between object.
        """
        ...


def _set_distance_metric(metric: str) -> DistMetricCallable:
    if metric == "lcss":
        return textdistance.lcsseq.distance
    if metric == "hamming":
        return textdistance.hamming.distance
    if metric == "levenshtein":
        return textdistance.levenshtein.distance
    if metric == "jaro":
        return textdistance.jaro.distance
    msg = "Metric can only be lcss, hamming, levenshtein, jaro or difflib."
    raise ValueError(msg)


def associate_entities(
    game_names: list[str | None] | None = None,
    entity_names: list[str] | None = None,
    metric: Literal["lcss", "hamming", "levenshtein", "jaro", "difflib"] = "lcss",
) -> dict:
    """A function to return a dict of associated entities. Accepts.

    Args:
        game_names (list, optional): A list of names generated by the demofile.
            Defaults to []
        entity_names (list, optional): A list of names: Defaults to []
        metric (string, optional): A string indicating distance metric,
            one of lcss, hamming, levenshtein, jaro, difflib.
            Defaults to 'lcss'

    Returns:
        A dictionary where the keys are entries in game_names,
        values are the matched entity names.

    Raises:
        ValueError: If metric is not in:
            ["lcss", "hamming", "levenshtein", "jaro", "difflib"]
    """
    if game_names is None:
        game_names = []
    if entity_names is None:
        entity_names = []
    entities: dict[str | None, Any] = {}
    if metric.lower() == "difflib":
        for game_name in game_names:
            if game_name is not None and game_name is not np.nan:
                closest_name = difflib.get_close_matches(
                    game_name, entity_names, n=1, cutoff=0.0
                )
                entities[game_name] = closest_name[0] if len(closest_name) > 0 else None
        entities[None] = None
        return entities

    dist_metric = _set_distance_metric(metric.lower())
    for game_name in game_names:
        if (
            game_name is not None
            and game_name is not np.nan
            and game_name != ""
            and len(entity_names) > 0
        ):
            name_distances = []
            names = []
            for player in entity_names:
                name_distances.append(dist_metric(game_name.lower(), player.lower()))
                names.append(player)
            entities[game_name] = names[np.argmin(name_distances)]
            entity_names.pop(np.argmin(name_distances))
        if game_name == "":
            entities[game_name] = None
    entities[None] = None
    return entities


def replace_entities(
    dataframe: pd.DataFrame, col_name: str, entity_dict: dict
) -> pd.DataFrame:
    """A function to replace values in a Pandas df column given an entity dict.

    entity_dict as created in associate_entities().

    Args:
        dataframe (DataFrame) : A Pandas DataFrame
        col_name (string)  : A column in the Pandas DataFrame
        entity_dict (dict) : A dictionary as created in associate_entities()

    Returns:
        A dataframe with replaced names.
    """
    if col_name not in dataframe.columns:
        msg = "Column does not exist!"
        raise KeyError(msg)
    dataframe[col_name] = dataframe[col_name].replace(entity_dict)
    return dataframe
